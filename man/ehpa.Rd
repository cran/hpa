% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{ehpa}
\alias{ehpa}
\title{Expected powered product hermite polynomial approximation}
\usage{
ehpa(
  x = matrix(1, 1),
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  given_ind = logical(0),
  omit_ind = logical(0),
  mean = numeric(0),
  sd = numeric(0),
  expectation_powers = numeric(0),
  is_parallel = FALSE
)
}
\arguments{
\item{x}{non-negative numeric matrix of quantiles.
Note that \code{x} rows are observations while variables are columns.}

\item{pol_coefficients}{numeric vector of polynomial coefficients.}

\item{pol_degrees}{non-negative integer vector of polynomial degrees.}

\item{given_ind}{logical vector indicating wheather corresponding
component is conditioned. By default it is a logical vector of FALSE values.}

\item{omit_ind}{logical vector indicating wheather corresponding
component is omitted. By default it is a logical vector of FALSE values.}

\item{mean}{numeric vector of expected values.}

\item{sd}{positive numeric vector of standard deviations.}

\item{expectation_powers}{integer vector of random vector components powers.}

\item{is_parallel}{if TRUE then multiple cores will be 
used for some calculations.}
}
\value{
This function returns numeric vector of expected powered product hermite polynomial approximations.
}
\description{
This function calculates expected powered product hermite polynomial approximation.
}
\details{
Expected powered product of random variables is expectation of
their product given powers \code{expectation_powers}. Therefore in order to approximate
expected value of i-th random vector component just set all 
\code{expectation_powers} to zero except it's i-th component which should
be assigned 1.

Densities hermite polynomial approximation approach has been proposed by A. Gallant and D. W. Nychka in 1987.
The main idea is to approximate unknown distribution density with hermite polynomial of degree \code{pol_degree}. 
In this framework hermite polynomial represents adjusted (to insure integration to 1) product of squared polynomial and normal distribution densities.
Parameters \code{mean} and \code{sd} determine means and standard deviations of normal distribution density functions
which are parts of this polynomial.
For more information please refer to the literature listed below.

Parameters \code{mean}, \code{sd}, \code{given_ind}, \code{omit_ind}
should have the same length as \code{pol_degrees} parameter.
}
\examples{
##Let's approximate some three random variables powered product expectation for 
##powers (3,2,1) with hermite polynomial of (1,2,3) degrees which polynomial coefficients
##equals 1 except coefficient related to x1*(x^3) polynomial element which equals 2.
## Also suppose that normal density related mean vector equals (1.1, 1.2, 1.3) while
## standard deviations vector is (2.1, 2.2, 2.3).

#Prepare initial values
expectation_powers = c(3,2,1)
mean <- c(1.1, 1.2, 1.3)
sd <- c(2.1, 2.2, 2.3)
pol_degrees <- c(1, 2, 3)

#Create polynomial powers and indexes correspondence matrix
pol_ind <- polynomialIndex(pol_degrees)

#Set all polynomial coefficients to 1
pol_coefficients <- rep(1, ncol(pol_ind))
pol_degrees_n <- length(pol_degrees)

#Assign coefficient 2 to the polynomial element (x1 ^ 1)*(x2 ^ 0)*(x3 ^ 2)
pol_coefficients[which(colSums(pol_ind == c(1, 0, 2)) == pol_degrees_n)] <- 2

#Visualize correspondence between polynomial elements and their coefficients
as.data.frame(rbind(pol_ind, pol_coefficients),
	row.names = c("x1 power", "x2 power", "x3 power", "coefficients"),
	optional = TRUE)
printPolynomial(pol_degrees, pol_coefficients)

#Calculate expected powered product approximation
ehpa(pol_coefficients = pol_coefficients, pol_degrees = pol_degrees,
	mean = mean, sd = sd, expectation_powers = expectation_powers)
	
#Condition second component to be 0.5
#Substitute x second component with conditional value 0.5
x <- matrix(c(NA, 0.5, NA), nrow = 1)
#Set TRUE to the second component indicating that it is conditioned
given_ind <- c(FALSE, TRUE, FALSE)

#Calculate conditional(on x2 = 0.5) expected powered product approximation
ehpa(x = x,
	pol_coefficients = pol_coefficients, pol_degrees = pol_degrees,
	mean = mean, sd = sd, expectation_powers = expectation_powers,
	given_ind = given_ind)
	
#Consider third component marginal distribution
#conditioned on the second component 0.5 value
#Set TRUE to the first component indicating that it is omitted
omit_ind <- c(TRUE, FALSE, FALSE)

#Calculate conditional (on x2=0.5) marginal (for x3) expected powered 
#product approximation at points x_lower and x_upper
ehpa(x = x,
	pol_coefficients = pol_coefficients, pol_degrees = pol_degrees,
	mean = mean, sd = sd, expectation_powers = expectation_powers,
	given_ind = given_ind, omit_ind = omit_ind)
}
\references{
A. Gallant and D. W. Nychka (1987) <doi:10.2307/1913241>
}
